<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Constrained FWI with · Slim Optimization toolbox</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Slim Optimization toolbox</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../01_denoising/">Denoising</a></li><li><a class="tocitem" href="../02_simple_constrained/">Constrained Inversion, basics</a></li><li class="is-active"><a class="tocitem" href>Constrained FWI with</a><ul class="internal"><li><a class="tocitem" href="#.-Prepare-models"><span>1. Prepare models</span></a></li><li><a class="tocitem" href="#Visualize"><span>Visualize</span></a></li><li><a class="tocitem" href="#.-Setup-Constraints-with-[SetIntersectionProjection](https://github.com/slimgroup/SetIntersectionProjection.jl)"><span>2. Setup Constraints with SetIntersectionProjection</span></a></li><li><a class="tocitem" href="#.-Build-a-small-local-compute-cluster-(2-workers)"><span>3. Build a small local compute cluster (2 workers)</span></a></li><li><a class="tocitem" href="#.-Create-source-and-receivers-geometries"><span>4. Create source and receivers geometries</span></a></li><li><a class="tocitem" href="#.-Build-F,-the-JUDI-modeling-operator"><span>5. Build <code>F</code>, the JUDI modeling operator</span></a></li><li><a class="tocitem" href="#.-Use-F-to-create-the-data-in-both-models"><span>6. Use <code>F</code> to create the data in both models</span></a></li><li><a class="tocitem" href="#.-Visualize-data"><span>7. Visualize data</span></a></li><li><a class="tocitem" href="#.-Assess-if-data-is-cycle-skipped-at-the-farthest-offsets"><span>8. Assess if data is cycle skipped at the farthest offsets</span></a></li><li><a class="tocitem" href="#.-Build-the-objective-functions"><span>9. Build the <code>objective</code> functions</span></a></li><li><a class="tocitem" href="#.-Perform-the-FWI-using-minConf_PQN"><span>10. Perform the FWI using <code>minConf_PQN</code></span></a></li><li><a class="tocitem" href="#.-Visualize-velocity-models-and-objective-function"><span>11. Visualize velocity models and objective function</span></a></li><li><a class="tocitem" href="#.-Visualize-data-match"><span>12. Visualize data match</span></a></li><li><a class="tocitem" href="#.-Remove-workers"><span>14. Remove workers</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Constrained FWI with</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Constrained FWI with</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/slimgroup/SlimOptim.jl/blob/master/docs/src/tutorials/03_constr_fwi_judi.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Constrained-FWI-with"><a class="docs-heading-anchor" href="#Constrained-FWI-with">Constrained FWI with</a><a id="Constrained-FWI-with-1"></a><a class="docs-heading-anchor-permalink" href="#Constrained-FWI-with" title="Permalink"></a></h1><p>This tutorials demonstrates the use of constrains for FWI. The wave equation is performed with <a href="https://github.com/slimgroup/JUDI.jl">JUDI</a> and the projections wiht <a href="https://github.com/slimgroup/SetIntersectionProjection.jl">SetIntersectionProjection</a>.</p><h4 id="Note-on-runtime"><a class="docs-heading-anchor" href="#Note-on-runtime">Note on runtime</a><a id="Note-on-runtime-1"></a><a class="docs-heading-anchor-permalink" href="#Note-on-runtime" title="Permalink"></a></h4><p>Warning: this notebook takes more than 1 hour to run for 16 shots with two workers on an Intel 8168.</p><p><code>lscpu</code> CPU information: <code>Intel(R) Xeon(R) Platinum 8168 CPU @ 2.70GHz</code></p><pre><code class="language-julia">using SlimOptim
using Distributed, JUDI.TimeModeling, LinearAlgebra, PyPlot, SetIntersectionProjection, Printf</code></pre><pre><code class="language-none">┌ Info: Precompiling SetIntersectionProjection [335f7d24-6316-57dd-9c3a-df470f2b739e]
└ @ Base loading.jl:1278</code></pre><h2 id=".-Prepare-models"><a class="docs-heading-anchor" href="#.-Prepare-models">1. Prepare models</a><a id=".-Prepare-models-1"></a><a class="docs-heading-anchor-permalink" href="#.-Prepare-models" title="Permalink"></a></h2><pre><code class="language-julia">n = (251, 251) # nx, nz
d = (15., 15.) # hx, hz
o = (0., 0.); # ox, oz</code></pre><pre><code class="language-julia"># Squared slowness
m = 1.5f0^(-2) * ones(Float32, n)
m[101:150, 101:150] .= 1.7f0^(-2)
m0 = 1/1.5^2 * ones(Float32, n);</code></pre><pre><code class="language-julia">model = Model(n,d,o,m)
model0 = Model(n,d,o,m0);</code></pre><h2 id="Visualize"><a class="docs-heading-anchor" href="#Visualize">Visualize</a><a id="Visualize-1"></a><a class="docs-heading-anchor-permalink" href="#Visualize" title="Permalink"></a></h2><pre><code class="language-julia">figure(figsize=(8,9))
vmin,vmax = extrema(m)
dmin,dmax = -.1,.1

subplot(3,1,1); imshow(m,aspect=&quot;auto&quot;,cmap=&quot;jet&quot;); 
colorbar(); clim(vmin,vmax); title(&quot;True squared slowness (m)&quot;)

subplot(3,1,2); imshow(m0,aspect=&quot;auto&quot;,cmap=&quot;jet&quot;);
colorbar(); clim(vmin,vmax); title(&quot;Initial squared slowness (m0)&quot;);

subplot(3,1,3); imshow(m.-m0,aspect=&quot;auto&quot;,cmap=&quot;seismic&quot;);
colorbar(); clim(dmin,dmax); title(&quot;Difference (m-m0)&quot;);

tight_layout()</code></pre><p><img src="../03_constr_fwi_judi_files/03_constr_fwi_judi_7_0.png" alt="png"/></p><h2 id=".-Setup-Constraints-with-[SetIntersectionProjection](https://github.com/slimgroup/SetIntersectionProjection.jl)"><a class="docs-heading-anchor" href="#.-Setup-Constraints-with-[SetIntersectionProjection](https://github.com/slimgroup/SetIntersectionProjection.jl)">2. Setup Constraints with <a href="https://github.com/slimgroup/SetIntersectionProjection.jl">SetIntersectionProjection</a></a><a id=".-Setup-Constraints-with-[SetIntersectionProjection](https://github.com/slimgroup/SetIntersectionProjection.jl)-1"></a><a class="docs-heading-anchor-permalink" href="#.-Setup-Constraints-with-[SetIntersectionProjection](https://github.com/slimgroup/SetIntersectionProjection.jl)" title="Permalink"></a></h2><pre><code class="language-julia">options=PARSDMM_options()
options.FL=Float32
options=default_PARSDMM_options(options,options.FL)
constraint = Vector{SetIntersectionProjection.set_definitions}()
constraint2 = Vector{SetIntersectionProjection.set_definitions}()</code></pre><pre><code class="language-none">set_definitions[]</code></pre><p>We setup two constaints:</p><ul><li>Bounds that limit maximum and minimum velocity</li><li>TV, that limits variation and force a piece-wise constant structure</li></ul><pre><code class="language-julia">#bounds:
m_min = 0 .* m .+ minimum(m).*.5
m_max = 0 .* m .+ maximum(m)
set_type = &quot;bounds&quot;
TD_OP = &quot;identity&quot;
app_mode = (&quot;matrix&quot;,&quot;&quot;)
custom_TD_OP = ([],false)
push!(constraint, set_definitions(set_type,TD_OP,vec(m_min),vec(m_max),app_mode,custom_TD_OP));
push!(constraint2, set_definitions(set_type,TD_OP,vec(m_min),vec(m_max),app_mode,custom_TD_OP));</code></pre><pre><code class="language-julia">#TV
(TV,dummy1,dummy2,dummy3) = get_TD_operator(model0,&quot;TV&quot;,options.FL)
m_min = 0.0
m_max = norm(TV*vec(m),1) * .5
set_type = &quot;l1&quot;
TD_OP = &quot;TV&quot;
app_mode = (&quot;matrix&quot;,&quot;&quot;)
custom_TD_OP = ([],false)
push!(constraint, set_definitions(set_type,TD_OP,m_min,m_max,app_mode,custom_TD_OP));</code></pre><pre><code class="language-julia">#set up constraints with bounds only, precompute some things and define projector
(P_sub2,TD_OP2,set_Prop2) = setup_constraints(constraint2, model0,options.FL)
(TD_OP2,AtA2,l2,y2) = PARSDMM_precompute_distribute(TD_OP2,set_Prop2,model0,options)
options2 = deepcopy(options)
options2.rho_ini = ones(length(TD_OP2))*10.0

proj_intersection2 = x-&gt; PARSDMM(x, AtA2, TD_OP2, set_Prop2, P_sub2, model0, options2)  

# Projection function
function prj2(input)
    input = Float32.(input)
    (x,dummy1,dummy2,dymmy3) = proj_intersection2(vec(input))
    return x
end</code></pre><pre><code class="language-none">prj2 (generic function with 1 method)</code></pre><pre><code class="language-julia">#set up constraints with bounds and TV
(P_sub,TD_OP,set_Prop) = setup_constraints(constraint, model0,options.FL)
(TD_OP,AtA,l,y) = PARSDMM_precompute_distribute(TD_OP,set_Prop,model0,options)
options.rho_ini = ones(length(TD_OP))*10.0

proj_intersection = x-&gt; PARSDMM(x, AtA, TD_OP, set_Prop, P_sub, model0, options)

# Projection function
function prj(input)
    input = Float32.(input)
    (x,dummy1,dummy2,dymmy3) = proj_intersection(vec(input))
    return x
end</code></pre><pre><code class="language-none">prj (generic function with 1 method)</code></pre><h2 id=".-Build-a-small-local-compute-cluster-(2-workers)"><a class="docs-heading-anchor" href="#.-Build-a-small-local-compute-cluster-(2-workers)">3. Build a small local compute cluster (2 workers)</a><a id=".-Build-a-small-local-compute-cluster-(2-workers)-1"></a><a class="docs-heading-anchor-permalink" href="#.-Build-a-small-local-compute-cluster-(2-workers)" title="Permalink"></a></h2><h4 id="Setup-OMP-environment-variables-for-the-cluster"><a class="docs-heading-anchor" href="#Setup-OMP-environment-variables-for-the-cluster">Setup OMP environment variables for the cluster</a><a id="Setup-OMP-environment-variables-for-the-cluster-1"></a><a class="docs-heading-anchor-permalink" href="#Setup-OMP-environment-variables-for-the-cluster" title="Permalink"></a></h4><p>In the distributed compute case the workers that we add would be on different hardware, and we might add tens of workers in 2D and hundreds in 3D. Here we run on a single machine with only 2 workers, and so we need to be careful with details related to high performance computing. If we did not specify thread affinity, the two workers would compete for the same physical cores and the modeling would be <em>incredibly</em> slow.</p><p>We spin up the small 2-worker cluster by calling <code>addprocs(2)</code>, and because we set the environment variable <code>ENV[&quot;OMP_DISPLAY_ENV&quot;] = &quot;true&quot;</code> we will see the OMP environment printed out on each worker. In that output (below) we can verify that half of the total threads (44/2 = 22) are assigned to each socket on this 2 socket system. You can obtain more details about the hardware with the shell command <code>lscpu</code>.</p><p>We set four environment variables related to OpenMP:</p><ul><li><code>OMP_DISPLAY_ENV</code> prints out the OpenMP environment on each worker</li><li><code>OMP_PROC_BIND</code> specifies that threads should be bound to physical cores</li><li><code>OMP_NUM_THREADS</code> specifies the number of threads per workers is 1/2 the number of physical cores</li><li><code>GOMP_CPU_AFFINITY</code> specifies which physical cores the threads run on for each worker</li></ul><p>If you run the shell command <code>top</code> during execution, you will see 3 julia processes: the main process and two workers. The two workers should generally have about 50% of the system, and <code>load average</code> should tend towards the physical number of cores.</p><pre><code class="language-julia">nthread = Sys.CPU_THREADS
nw = 2

ENV[&quot;OMP_DISPLAY_ENV&quot;] = &quot;true&quot;
ENV[&quot;OMP_PROC_BIND&quot;] = &quot;close&quot;
ENV[&quot;OMP_NUM_THREADS&quot;] = &quot;$(div(nthread, nw))&quot; 
addprocs(nw)
@show workers()
for k in 1:nworkers()
    place1 = (k - 1) * div(nthread,nworkers())
    place2 = (k + 0) * div(nthread,nworkers()) - 1
    @show place1, place2, div(nthread, nw)
    @spawnat workers()[k] ENV[&quot;GOMP_CPU_AFFINITY&quot;] = &quot;$(place1)-$(place2)&quot;;
end</code></pre><pre><code class="language-none">workers() = [2, 3]
(place1, place2, div(nthread, nw)) = (0, 3, 4)
(place1, place2, div(nthread, nw)) = (4, 7, 4)</code></pre><pre><code class="language-julia">@everywhere using Distributed, JUDI.TimeModeling, JUDI.SLIM_optim, LinearAlgebra, PyPlot, SetIntersectionProjection</code></pre><pre><code class="language-none">      From worker 2:	
      From worker 2:	OPENMP DISPLAY ENVIRONMENT BEGIN
      From worker 2:	  _OPENMP = &#39;201511&#39;
      From worker 2:	  OMP_DYNAMIC = &#39;FALSE&#39;
      From worker 2:	  OMP_NESTED = &#39;FALSE&#39;
      From worker 2:	  OMP_NUM_THREADS = &#39;4&#39;
      From worker 2:	  OMP_SCHEDULE = &#39;DYNAMIC&#39;
      From worker 2:	  OMP_PROC_BIND = &#39;CLOSE&#39;
      From worker 2:	  OMP_PLACES = &#39;{0},{1},{2},{3}&#39;
      From worker 2:	  OMP_STACKSIZE = &#39;0&#39;
      From worker 2:	  OMP_WAIT_POLICY = &#39;PASSIVE&#39;
      From worker 2:	  OMP_THREAD_LIMIT = &#39;4294967295&#39;
      From worker 2:	  OMP_MAX_ACTIVE_LEVELS = &#39;2147483647&#39;
      From worker 2:	  OMP_CANCELLATION = &#39;FALSE&#39;
      From worker 2:	  OMP_DEFAULT_DEVICE = &#39;0&#39;
      From worker 2:	  OMP_MAX_TASK_PRIORITY = &#39;0&#39;
      From worker 2:	  OMP_DISPLAY_AFFINITY = &#39;FALSE&#39;
      From worker 2:	  OMP_AFFINITY_FORMAT = &#39;level %L thread %i affinity %A&#39;
      From worker 2:	OPENMP DISPLAY ENVIRONMENT END
      From worker 3:	
      From worker 3:	OPENMP DISPLAY ENVIRONMENT BEGIN
      From worker 3:	  _OPENMP = &#39;201511&#39;
      From worker 3:	  OMP_DYNAMIC = &#39;FALSE&#39;
      From worker 3:	  OMP_NESTED = &#39;FALSE&#39;
      From worker 3:	  OMP_NUM_THREADS = &#39;4&#39;
      From worker 3:	  OMP_SCHEDULE = &#39;DYNAMIC&#39;
      From worker 3:	  OMP_PROC_BIND = &#39;CLOSE&#39;
      From worker 3:	  OMP_PLACES = &#39;{4},{5},{6},{7}&#39;
      From worker 3:	  OMP_STACKSIZE = &#39;0&#39;
      From worker 3:	  OMP_WAIT_POLICY = &#39;PASSIVE&#39;
      From worker 3:	  OMP_THREAD_LIMIT = &#39;4294967295&#39;
      From worker 3:	  OMP_MAX_ACTIVE_LEVELS = &#39;2147483647&#39;
      From worker 3:	  OMP_CANCELLATION = &#39;FALSE&#39;
      From worker 3:	  OMP_DEFAULT_DEVICE = &#39;0&#39;
      From worker 3:	  OMP_MAX_TASK_PRIORITY = &#39;0&#39;
      From worker 3:	  OMP_DISPLAY_AFFINITY = &#39;FALSE&#39;
      From worker 3:	  OMP_AFFINITY_FORMAT = &#39;level %L thread %i affinity %A&#39;
      From worker 3:	OPENMP DISPLAY ENVIRONMENT END
      From worker 2:	
      From worker 2:	OPENMP DISPLAY ENVIRONMENT BEGIN
      From worker 2:	  _OPENMP = &#39;201511&#39;
      From worker 2:	  OMP_DYNAMIC = &#39;FALSE&#39;
      From worker 2:	  OMP_NESTED = &#39;FALSE&#39;
      From worker 2:	  OMP_NUM_THREADS = &#39;4&#39;
      From worker 2:	  OMP_SCHEDULE = &#39;DYNAMIC&#39;
      From worker 2:	  OMP_PROC_BIND = &#39;CLOSE&#39;
      From worker 2:	  OMP_PLACES = &#39;{0},{1},{2},{3}&#39;
      From worker 2:	  OMP_STACKSIZE = &#39;0&#39;
      From worker 2:	  OMP_WAIT_POLICY = &#39;PASSIVE&#39;
      From worker 2:	  OMP_THREAD_LIMIT = &#39;4294967295&#39;
      From worker 2:	  OMP_MAX_ACTIVE_LEVELS = &#39;2147483647&#39;
      From worker 2:	  OMP_CANCELLATION = &#39;FALSE&#39;
      From worker 2:	  OMP_DEFAULT_DEVICE = &#39;0&#39;
      From worker 2:	  OMP_MAX_TASK_PRIORITY = &#39;0&#39;
      From worker 2:	  OMP_DISPLAY_AFFINITY = &#39;FALSE&#39;
      From worker 2:	  OMP_AFFINITY_FORMAT = &#39;level %L thread %i affinity %A&#39;
      From worker 2:	OPENMP DISPLAY ENVIRONMENT END
      From worker 3:	
      From worker 3:	OPENMP DISPLAY ENVIRONMENT BEGIN
      From worker 3:	  _OPENMP = &#39;201511&#39;
      From worker 3:	  OMP_DYNAMIC = &#39;FALSE&#39;
      From worker 3:	  OMP_NESTED = &#39;FALSE&#39;
      From worker 3:	  OMP_NUM_THREADS = &#39;4&#39;
      From worker 3:	  OMP_SCHEDULE = &#39;DYNAMIC&#39;
      From worker 3:	  OMP_PROC_BIND = &#39;CLOSE&#39;
      From worker 3:	  OMP_PLACES = &#39;{4},{5},{6},{7}&#39;
      From worker 3:	  OMP_STACKSIZE = &#39;0&#39;
      From worker 3:	  OMP_WAIT_POLICY = &#39;PASSIVE&#39;
      From worker 3:	  OMP_THREAD_LIMIT = &#39;4294967295&#39;
      From worker 3:	  OMP_MAX_ACTIVE_LEVELS = &#39;2147483647&#39;
      From worker 3:	  OMP_CANCELLATION = &#39;FALSE&#39;
      From worker 3:	  OMP_DEFAULT_DEVICE = &#39;0&#39;
      From worker 3:	  OMP_MAX_TASK_PRIORITY = &#39;0&#39;
      From worker 3:	  OMP_DISPLAY_AFFINITY = &#39;FALSE&#39;
      From worker 3:	  OMP_AFFINITY_FORMAT = &#39;level %L thread %i affinity %A&#39;
      From worker 3:	OPENMP DISPLAY ENVIRONMENT END</code></pre><h2 id=".-Create-source-and-receivers-geometries"><a class="docs-heading-anchor" href="#.-Create-source-and-receivers-geometries">4. Create source and receivers geometries</a><a id=".-Create-source-and-receivers-geometries-1"></a><a class="docs-heading-anchor-permalink" href="#.-Create-source-and-receivers-geometries" title="Permalink"></a></h2><p>We use 8 shot locations evenly distributed across the left of the model.</p><pre><code class="language-julia">tn = 3500  # Recording time in ms
dt = 2f0  # Shot record sampling rate in ms
f0 = 0.005 # Peak frquency in kHz</code></pre><pre><code class="language-none">0.005</code></pre><pre><code class="language-julia">nsrc = 8
xsrc = convertToCell(d[1].*ones(Float32, nsrc))
ysrc = convertToCell(range(0f0, stop = 0f0, length = nsrc))
zsrc = convertToCell(range(0f0, (n[2] - 1)*d[2], length=nsrc))
src_geom = Geometry(xsrc, ysrc, zsrc; dt=dt, t=tn);</code></pre><pre><code class="language-julia">nrec = 251
xrec = (n[1] - 2)*d[1] .* ones(Float32, nrec)
yrec = 0f0
zrec = convertToCell(range(0f0, (n[2] - 1)*d[2], length=nrec))
rec_geom = Geometry(xrec, yrec, zrec; dt=dt, t=tn, nsrc=nsrc);</code></pre><h4 id="Visualize-geometry"><a class="docs-heading-anchor" href="#Visualize-geometry">Visualize geometry</a><a id="Visualize-geometry-1"></a><a class="docs-heading-anchor-permalink" href="#Visualize-geometry" title="Permalink"></a></h4><pre><code class="language-julia">figure()
vmin,vmax = extrema(m)
dmin,dmax = -.1,.1

imshow(m,aspect=&quot;auto&quot;,cmap=&quot;jet&quot;, extent=[0, 3750, 3750, 0]); 
colorbar(); clim(vmin,vmax); title(&quot;True squared slowness (m)&quot;)
scatter(xsrc, zsrc, c=&quot;g&quot;, label=&quot;Sources&quot;)
scatter(xrec[1:4:end], zrec[1:4:end], c=&quot;c&quot;, label=&quot;Receiver&quot;)
legend()</code></pre><p><img src="../03_constr_fwi_judi_files/03_constr_fwi_judi_23_0.png" alt="png"/></p><pre><code class="language-none">PyObject &lt;matplotlib.legend.Legend object at 0x7f90626162b0&gt;</code></pre><h2 id=".-Build-F,-the-JUDI-modeling-operator"><a class="docs-heading-anchor" href="#.-Build-F,-the-JUDI-modeling-operator">5. Build <code>F</code>, the JUDI modeling operator</a><a id=".-Build-F,-the-JUDI-modeling-operator-1"></a><a class="docs-heading-anchor-permalink" href="#.-Build-F,-the-JUDI-modeling-operator" title="Permalink"></a></h2><pre><code class="language-julia"># True model operator
ntComp = get_computational_nt(src_geom, rec_geom, model)
info = Info(prod(n), nsrc, ntComp)
F = judiModeling(info, model, src_geom, rec_geom)

# Intial model operator
ntComp = get_computational_nt(src_geom, rec_geom, model0)
info = Info(prod(n), nsrc,ntComp)
F0 = judiModeling(info, model0, src_geom, rec_geom);</code></pre><pre><code class="language-julia"># Source function
fsrc = judiVector(src_geom, ricker_wavelet(tn, dt, f0));</code></pre><h2 id=".-Use-F-to-create-the-data-in-both-models"><a class="docs-heading-anchor" href="#.-Use-F-to-create-the-data-in-both-models">6. Use <code>F</code> to create the data in both models</a><a id=".-Use-F-to-create-the-data-in-both-models-1"></a><a class="docs-heading-anchor-permalink" href="#.-Use-F-to-create-the-data-in-both-models" title="Permalink"></a></h2><pre><code class="language-julia">t1 = @elapsed begin
    dobs = F*fsrc;
end
@info @sprintf(&quot;Time in true model; %.2f seconds\n&quot;, t1);

t2 = @elapsed begin
    d0 = F0*fsrc;
end
@info @sprintf(&quot;Time in init model; %.2f seconds\n&quot;, t2);</code></pre><pre><code class="language-none">┌ Info: Time in true model; 17.57 seconds
└ @ Main In[20]:4
┌ Info: Time in init model; 6.78 seconds
└ @ Main In[20]:9</code></pre><h4 id="Compute-the-residual-data"><a class="docs-heading-anchor" href="#Compute-the-residual-data">Compute the residual data</a><a id="Compute-the-residual-data-1"></a><a class="docs-heading-anchor-permalink" href="#Compute-the-residual-data" title="Permalink"></a></h4><pre><code class="language-julia">r = d0 - dobs;</code></pre><h2 id=".-Visualize-data"><a class="docs-heading-anchor" href="#.-Visualize-data">7. Visualize data</a><a id=".-Visualize-data-1"></a><a class="docs-heading-anchor-permalink" href="#.-Visualize-data" title="Permalink"></a></h2><pre><code class="language-julia">shots = [1,4,8]</code></pre><pre><code class="language-none">3-element Array{Int64,1}:
 1
 4
 8</code></pre><h4 id="Plot-shot-gathers-for-true-model,-initial-model,-and-residual"><a class="docs-heading-anchor" href="#Plot-shot-gathers-for-true-model,-initial-model,-and-residual">Plot shot gathers for true model, initial model, and residual</a><a id="Plot-shot-gathers-for-true-model,-initial-model,-and-residual-1"></a><a class="docs-heading-anchor-permalink" href="#Plot-shot-gathers-for-true-model,-initial-model,-and-residual" title="Permalink"></a></h4><p>The table below describes the data images below. We flip the direction of the residual and modeled data in order to help display the match with the true data.</p><table style="border:1px solid black;" width="60%">
<tr>
  <td style="border:1px solid black; text-align:center;" bgcolor="white">
      <b>Initial Residual Data<br>(flipped)</b></td>
  <td style="border:1px solid black; text-align:center;" bgcolor="white">
      <b>True Data</b></td>
  <td style="border:1px solid black; text-align:center;" bgcolor="white">
      <b>Initial Data<br>(flipped)</b></td>
</tr>
</table><p>Note that the data modeled in the initial model lacks a lot of reflectivity that is evident in the data modeled in the true model. We expect to recover this missing reflectivity with the FWI.</p><pre><code class="language-julia">scale = 10.0 / sqrt(norm(dobs)^2 / length(dobs.data))
@show scale

nzero = 5
pad = ones(Float32,1751,nzero)

figure(figsize=(8,9)); clf()
for (iplot,ishot) in enumerate(shots)
    cat2 = hcat(reverse(r.data[ishot],dims=2), pad, dobs.data[ishot], pad, reverse(d0.data[ishot],dims=2))
    subplot(3,1,iplot);
    imshow(cat2,cmap=&quot;gray&quot;,aspect=&quot;auto&quot;,clim=[-1,+1]);
    title(&quot; Initial Residual sz=$(zsrc[ishot])   |   True sz=$(zsrc[ishot])   |   Initial sz=$(zsrc[ishot]) (flipped)&quot;);
end
tight_layout()</code></pre><p><img src="../03_constr_fwi_judi_files/03_constr_fwi_judi_34_0.png" alt="png"/></p><pre><code class="language-none">scale = 0.01818860621034772</code></pre><h2 id=".-Assess-if-data-is-cycle-skipped-at-the-farthest-offsets"><a class="docs-heading-anchor" href="#.-Assess-if-data-is-cycle-skipped-at-the-farthest-offsets">8. Assess if data is cycle skipped at the farthest offsets</a><a id=".-Assess-if-data-is-cycle-skipped-at-the-farthest-offsets-1"></a><a class="docs-heading-anchor-permalink" href="#.-Assess-if-data-is-cycle-skipped-at-the-farthest-offsets" title="Permalink"></a></h2><p>Next we plot the far offset traces for these three shots in order to assess if the data is cycle skipped. </p><p>You can ovbserve in the plots below that the refraction waveforms (first arrivals) in the initial model are not cycle skipped with respect to the true model, so we can proceed. </p><p>A very significant part of the residual wavefield is actually reflections in this example.</p><pre><code class="language-julia">scale = 10.0 / sqrt(norm(dobs)^2 / length(dobs.data))
t = [0.0:dt:tn;]

figure(figsize=(8,9)); clf()
for (iplot,ishot) in enumerate(shots)
    subplot(3,1,iplot);
    plot(t,dobs.data[ishot][:,end],label=&quot;True Model $(ishot) at z=$(zsrc[ishot])&quot;);
    plot(t,d0.data[ishot][:,end],label=&quot;Initial Model $(ishot) at z=$(zsrc[ishot])&quot;);
    xlim([4.5,t[end]])
    legend()
end
tight_layout()</code></pre><p><img src="../03_constr_fwi_judi_files/03_constr_fwi_judi_36_0.png" alt="png"/></p><h2 id=".-Build-the-objective-functions"><a class="docs-heading-anchor" href="#.-Build-the-objective-functions">9. Build the <code>objective</code> functions</a><a id=".-Build-the-objective-functions-1"></a><a class="docs-heading-anchor-permalink" href="#.-Build-the-objective-functions" title="Permalink"></a></h2><h4 id="Build-src/rec-positions-mask"><a class="docs-heading-anchor" href="#Build-src/rec-positions-mask">Build src/rec positions mask</a><a id="Build-src/rec-positions-mask-1"></a><a class="docs-heading-anchor-permalink" href="#Build-src/rec-positions-mask" title="Permalink"></a></h4><p>We use this mask to remove the imprint in gradients of proximity to source locations. The mask is set to 0 wherever a source or receiver is close, and is set to 1 otherwise. Without this mask most of the gradient updates would be concentrated close to sources where the model is correct. </p><pre><code class="language-julia">wb_mask = ones(Float32,size(m))
wb_mask[1:5, :] .= 0;
wb_mask[end-5:end, :] .= 0;

figure(figsize=(8,3))
imshow(wb_mask&#39;, aspect=&quot;auto&quot;,cmap=&quot;gray_r&quot;,clim=[0,+2]);
colorbar();
title(&quot;Water Bottom Mask&quot;);
tight_layout()</code></pre><p><img src="../03_constr_fwi_judi_files/03_constr_fwi_judi_39_0.png" alt="png"/></p><h4 id="Build-the-objective-function"><a class="docs-heading-anchor" href="#Build-the-objective-function">Build the <code>objective</code> function</a><a id="Build-the-objective-function-1"></a><a class="docs-heading-anchor-permalink" href="#Build-the-objective-function" title="Permalink"></a></h4><p>This method is called by the solver whenever the gradient is required. Steps in computing the gradient are as follows:</p><ol><li>Apply the adjoint of the Jacobian to the current residual <code>J&#39; * [F*v - d]</code> </li><li>Apply simple scaling based on the size of the first gradient, and save to apply to future gradients</li></ol><pre><code class="language-julia"># build Jacoian
J = judiJacobian(F0, fsrc)

function objective(F0, G, m, dobs, wb_mask)
    F0.model.m .= m
    t = @elapsed begin
        d0 = F0*fsrc
        G = J&#39; * (d0 .- dobs)
    end
    G .*= wb_mask
    ϕ = .5*norm(d0 .- dobs)^2
    if gscale == 0.0
        # compute scalar from first gradient, apply to future gradients
        global gscale = .25 ./ maximum(G) 
        @show gscale
    end
    G .*= gscale
    return ϕ, vec(G.data)
end

# struct to save the first gradient scalar
gscale = 0f0
g(x) = objective(F0, x, dobs, wb_mask)</code></pre><pre><code class="language-none">g (generic function with 1 method)</code></pre><h4 id="Compute-gradient"><a class="docs-heading-anchor" href="#Compute-gradient">Compute gradient</a><a id="Compute-gradient-1"></a><a class="docs-heading-anchor-permalink" href="#Compute-gradient" title="Permalink"></a></h4><pre><code class="language-julia">tgrad1 = @elapsed begin
    grad1 = objective(F0, vec(m0), dobs, wb_mask)[2]
    gscale = 0
end
@show tgrad1;</code></pre><pre><code class="language-none">gscale = 3.164575347982762e-5
tgrad1 = 20.692245796</code></pre><pre><code class="language-julia">dm = m0 .- m
grad1 = reshape(grad1, n)
mg2 = reshape(m0 .- grad1, n)
figure(figsize=(8,9))

subplot(5,1,1)
imshow(grad1&#39; ./ maximum(abs,grad1),aspect=&quot;auto&quot;,cmap=&quot;seismic&quot;);
colorbar(orientation=&quot;vertical&quot;);clim(-1,1);
title(&quot;Initial Gradient without Illumination Compensation&quot;);

subplot(5,1,2)
imshow(dm ./ maximum(abs,dm),aspect=&quot;auto&quot;,cmap=&quot;seismic&quot;);
colorbar(orientation=&quot;vertical&quot;);clim(-1,1);
title(&quot;Squared slowness Difference: (m0 - m)&quot;);

subplot(5,1,3)
imshow(mg2&#39;,aspect=&quot;auto&quot;,cmap=&quot;seismic&quot;);
colorbar(orientation=&quot;vertical&quot;);clim(vmin,vmax)
title(&quot;Updated squared slowness: (m0 - grad1)&quot;);

subplot(5,1,4)
imshow(reshape(prj(mg2), n)&#39;,aspect=&quot;auto&quot;,cmap=&quot;seismic&quot;);
colorbar(orientation=&quot;vertical&quot;);clim(vmin,vmax)
title(&quot;Updated projected (bounds + TV) squared slowness: prj(m0 - grad1)&quot;);

subplot(5,1,5)
imshow(reshape(prj2(mg2), n)&#39;,aspect=&quot;auto&quot;,cmap=&quot;seismic&quot;);
colorbar(orientation=&quot;vertical&quot;);clim(vmin,vmax)
title(&quot;Updated projected (bounds) squared slowness: prj(m0 - grad1)&quot;);

tight_layout()</code></pre><pre><code class="language-none">relative evolution to small, exiting PARSDMM (iteration 36)</code></pre><p><img src="../03_constr_fwi_judi_files/03_constr_fwi_judi_44_1.png" alt="png"/></p><pre><code class="language-none">Hello
input to PARSDMM is feasible, returning</code></pre><h2 id=".-Perform-the-FWI-using-minConf_PQN"><a class="docs-heading-anchor" href="#.-Perform-the-FWI-using-minConf_PQN">10. Perform the FWI using <code>minConf_PQN</code></a><a id=".-Perform-the-FWI-using-minConf_PQN-1"></a><a class="docs-heading-anchor-permalink" href="#.-Perform-the-FWI-using-minConf_PQN" title="Permalink"></a></h2><p>We will do 10 functions evaluation cost of projected quasi-Newton with two setup:</p><ul><li>Bounds constraints only</li><li>Bounds + tv constrains</li></ul><pre><code class="language-julia"># FWI with PQN
niter = 10
gscale = 0f0
options_pqn = pqn_options(progTol=0, store_trace=true, verbose=3, maxIter=niter)</code></pre><pre><code class="language-none">JUDI.SLIM_optim.PQN_params(3, 1.0f-5, 0, 10, 0.0001f0, 10, false, false, true, 1.0f-6, 1.0f-7, 10, false, 20)</code></pre><pre><code class="language-julia">sol = pqn(g, vec(m0), prj, options_pqn);</code></pre><pre><code class="language-none">Running PQN...
Number of L-BFGS Corrections to store: 10
Spectral initialization of SPG: 0
Maximum number of SPG iterations: 10
SPG optimality tolerance: 1.00e-06
SPG progress tolerance: 1.00e-07
PQN optimality tolerance: 1.00e-05
PQN progress tolerance: 0.00e+00
Quadratic initialization of line search: 0
Maximum number of function evaluations: 10
input to PARSDMM is feasible, returning
gscale = 3.164575347982762e-5
 Iteration   FunEvals Projections     Step Length    Function Val        Opt Cond
relative evolution to small, exiting PARSDMM (iteration 36)
         0          0          0     0.00000e+00     7.56888e+05     6.44959e-02
relative evolution to small, exiting PARSDMM (iteration 36)
relative evolution to small, exiting PARSDMM (iteration 36)
Cubic Backtracking
Cubic Backtracking
0.29970267128723044, (63001,)0.5874509773710214
relative evolution to small, exiting PARSDMM (iteration 31)
         1          4          5     2.74241e-01     4.56943e+05     2.89910e-02
relative evolution to small, exiting PARSDMM (iteration 31)
relative evolution to small, exiting PARSDMM (iteration 15)
relative evolution to small, exiting PARSDMM (iteration 15)
relative evolution to small, exiting PARSDMM (iteration 15)
relative evolution to small, exiting PARSDMM (iteration 15)
relative evolution to small, exiting PARSDMM (iteration 15)
relative evolution to small, exiting PARSDMM (iteration 15)
relative evolution to small, exiting PARSDMM (iteration 15)
relative evolution to small, exiting PARSDMM (iteration 15)
relative evolution to small, exiting PARSDMM (iteration 15)
relative evolution to small, exiting PARSDMM (iteration 15)
relative evolution to small, exiting PARSDMM (iteration 15)
relative evolution to small, exiting PARSDMM (iteration 15)
relative evolution to small, exiting PARSDMM (iteration 15)
0.3645347021520138, (63001,)0.5415892004966736
relative evolution to small, exiting PARSDMM (iteration 26)
         2          5         20     1.00000e+00     1.96831e+05     2.17257e-02
relative evolution to small, exiting PARSDMM (iteration 26)
relative evolution to small, exiting PARSDMM (iteration 15)
relative evolution to small, exiting PARSDMM (iteration 24)
relative evolution to small, exiting PARSDMM (iteration 15)
relative evolution to small, exiting PARSDMM (iteration 23)
relative evolution to small, exiting PARSDMM (iteration 15)
relative evolution to small, exiting PARSDMM (iteration 15)
relative evolution to small, exiting PARSDMM (iteration 15)
relative evolution to small, exiting PARSDMM (iteration 23)
relative evolution to small, exiting PARSDMM (iteration 15)
relative evolution to small, exiting PARSDMM (iteration 23)
relative evolution to small, exiting PARSDMM (iteration 15)
relative evolution to small, exiting PARSDMM (iteration 15)
relative evolution to small, exiting PARSDMM (iteration 15)
0.35030123218894005, (63001,)0.4920957423746586
relative evolution to small, exiting PARSDMM (iteration 27)
         3          6         35     1.00000e+00     8.08809e+04     2.08072e-02
relative evolution to small, exiting PARSDMM (iteration 27)
relative evolution to small, exiting PARSDMM (iteration 15)
relative evolution to small, exiting PARSDMM (iteration 26)
relative evolution to small, exiting PARSDMM (iteration 15)
relative evolution to small, exiting PARSDMM (iteration 25)
relative evolution to small, exiting PARSDMM (iteration 15)
relative evolution to small, exiting PARSDMM (iteration 25)
relative evolution to small, exiting PARSDMM (iteration 15)
relative evolution to small, exiting PARSDMM (iteration 25)
relative evolution to small, exiting PARSDMM (iteration 15)
relative evolution to small, exiting PARSDMM (iteration 25)
relative evolution to small, exiting PARSDMM (iteration 15)
relative evolution to small, exiting PARSDMM (iteration 25)
relative evolution to small, exiting PARSDMM (iteration 15)
relative evolution to small, exiting PARSDMM (iteration 25)
relative evolution to small, exiting PARSDMM (iteration 15)
0.3626699335873127, (63001,)0.4909360632300377
relative evolution to small, exiting PARSDMM (iteration 24)
         4          7         52     1.00000e+00     4.65027e+04     2.76750e-02
relative evolution to small, exiting PARSDMM (iteration 24)
relative evolution to small, exiting PARSDMM (iteration 15)
relative evolution to small, exiting PARSDMM (iteration 25)
relative evolution to small, exiting PARSDMM (iteration 15)
relative evolution to small, exiting PARSDMM (iteration 24)
relative evolution to small, exiting PARSDMM (iteration 14)
relative evolution to small, exiting PARSDMM (iteration 24)
relative evolution to small, exiting PARSDMM (iteration 14)
relative evolution to small, exiting PARSDMM (iteration 25)
relative evolution to small, exiting PARSDMM (iteration 15)
relative evolution to small, exiting PARSDMM (iteration 24)
relative evolution to small, exiting PARSDMM (iteration 15)
0.358932975679636, (63001,)0.478837039321661
relative evolution to small, exiting PARSDMM (iteration 14)
         5          8         65     1.00000e+00     3.00094e+04     2.34035e-02
relative evolution to small, exiting PARSDMM (iteration 14)
relative evolution to small, exiting PARSDMM (iteration 15)
relative evolution to small, exiting PARSDMM (iteration 23)
relative evolution to small, exiting PARSDMM (iteration 15)
relative evolution to small, exiting PARSDMM (iteration 27)
relative evolution to small, exiting PARSDMM (iteration 27)
0.3501978628337383, (63001,)0.4665626771748066
relative evolution to small, exiting PARSDMM (iteration 14)
         6          9         72     1.00000e+00     1.73936e+04     2.05345e-02
relative evolution to small, exiting PARSDMM (iteration 14)
relative evolution to small, exiting PARSDMM (iteration 15)
relative evolution to small, exiting PARSDMM (iteration 14)
relative evolution to small, exiting PARSDMM (iteration 15)
relative evolution to small, exiting PARSDMM (iteration 26)
relative evolution to small, exiting PARSDMM (iteration 15)
0.34992028027772903, (63001,)0.46518728509545326
relative evolution to small, exiting PARSDMM (iteration 14)
         7         10         79     1.00000e+00     1.26443e+04     1.34957e-02
relative evolution to small, exiting PARSDMM (iteration 14)
relative evolution to small, exiting PARSDMM (iteration 14)
relative evolution to small, exiting PARSDMM (iteration 14)
relative evolution to small, exiting PARSDMM (iteration 15)
relative evolution to small, exiting PARSDMM (iteration 14)
relative evolution to small, exiting PARSDMM (iteration 15)
relative evolution to small, exiting PARSDMM (iteration 14)
relative evolution to small, exiting PARSDMM (iteration 15)
relative evolution to small, exiting PARSDMM (iteration 14)
relative evolution to small, exiting PARSDMM (iteration 15)
relative evolution to small, exiting PARSDMM (iteration 14)
relative evolution to small, exiting PARSDMM (iteration 14)
relative evolution to small, exiting PARSDMM (iteration 14)
relative evolution to small, exiting PARSDMM (iteration 14)
relative evolution to small, exiting PARSDMM (iteration 14)
relative evolution to small, exiting PARSDMM (iteration 14)
relative evolution to small, exiting PARSDMM (iteration 14)
relative evolution to small, exiting PARSDMM (iteration 15)
0.34455902641639113, (63001,)0.4601459242403507
relative evolution to small, exiting PARSDMM (iteration 14)
         8         11         98     1.00000e+00     6.46003e+03     8.41045e-03
relative evolution to small, exiting PARSDMM (iteration 14)
relative evolution to small, exiting PARSDMM (iteration 14)
relative evolution to small, exiting PARSDMM (iteration 14)
relative evolution to small, exiting PARSDMM (iteration 15)
relative evolution to small, exiting PARSDMM (iteration 14)
relative evolution to small, exiting PARSDMM (iteration 15)
relative evolution to small, exiting PARSDMM (iteration 14)
relative evolution to small, exiting PARSDMM (iteration 15)
relative evolution to small, exiting PARSDMM (iteration 14)
relative evolution to small, exiting PARSDMM (iteration 14)
relative evolution to small, exiting PARSDMM (iteration 14)
relative evolution to small, exiting PARSDMM (iteration 14)
0.3416639202623628, (63001,)0.45731245446950197
relative evolution to small, exiting PARSDMM (iteration 14)
         9         12        111     1.00000e+00     4.24626e+03     6.41516e-03
relative evolution to small, exiting PARSDMM (iteration 14)
relative evolution to small, exiting PARSDMM (iteration 15)
relative evolution to small, exiting PARSDMM (iteration 14)
relative evolution to small, exiting PARSDMM (iteration 15)
relative evolution to small, exiting PARSDMM (iteration 14)
relative evolution to small, exiting PARSDMM (iteration 15)
relative evolution to small, exiting PARSDMM (iteration 14)
relative evolution to small, exiting PARSDMM (iteration 15)
relative evolution to small, exiting PARSDMM (iteration 14)
relative evolution to small, exiting PARSDMM (iteration 15)
0.3406056523381267, (63001,)0.45664693508297205
relative evolution to small, exiting PARSDMM (iteration 14)
        10         13        122     1.00000e+00     3.47106e+03     5.40122e-03</code></pre><pre><code class="language-julia">sol2 = minConf_PQN(g, vec(m0), prj2, options_pqn);</code></pre><pre><code class="language-none">Running PQN...
Number of L-BFGS Corrections to store: 10
Spectral initialization of SPG: 0
Maximum number of SPG iterations: 10
SPG optimality tolerance: 1.00e-06
SPG progress tolerance: 1.00e-07
PQN optimality tolerance: 1.00e-05
PQN progress tolerance: 0.00e+00
Quadratic initialization of line search: 0
Maximum number of function evaluations: 10
input to PARSDMM is feasible, returning
 Iteration   FunEvals Projections     Step Length    Function Val        Opt Cond
input to PARSDMM is feasible, returning
         0          0          0     0.00000e+00     7.56888e+05     2.50000e-01
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
Cubic Backtracking
0.37986092867546234, (63001,)0.6480796155205198
relative evolution to small, exiting PARSDMM (iteration 15)
         1          3          5     3.54968e-01     5.06750e+05     8.41055e-02
relative evolution to small, exiting PARSDMM (iteration 15)
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
0.35521354526281357, (63001,)0.5054220408201218
input to PARSDMM is feasible, returning
         2          4         24     1.00000e+00     1.11358e+05     5.56206e-02
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
0.3701881654560566, (63001,)0.4869217425584793
input to PARSDMM is feasible, returning
         3          5         39     1.00000e+00     6.61499e+04     4.28273e-02
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
0.373028289526701, (63001,)0.47711528558284044
input to PARSDMM is feasible, returning
         4          6         59     1.00000e+00     2.60822e+04     2.62599e-02
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
0.379634543787688, (63001,)0.4776479071006179
input to PARSDMM is feasible, returning
         5          7         79     1.00000e+00     1.40333e+04     2.08746e-02
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
0.3758693804265931, (63001,)0.4798321803100407
input to PARSDMM is feasible, returning
         6          8         99     1.00000e+00     5.61614e+03     9.52557e-03
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
0.377302254550159, (63001,)0.483893642667681
input to PARSDMM is feasible, returning
         7          9        119     1.00000e+00     3.39727e+03     9.15307e-03
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
0.3752191723906435, (63001,)0.48195909010246396
input to PARSDMM is feasible, returning
         8         10        139     1.00000e+00     2.48762e+03     6.99520e-03
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
0.37440903729293495, (63001,)0.4817936853505671
input to PARSDMM is feasible, returning
         9         11        159     1.00000e+00     1.94118e+03     5.18629e-03
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
input to PARSDMM is feasible, returning
0.372569696046412, (63001,)0.48126206363667734
input to PARSDMM is feasible, returning
        10         12        179     1.00000e+00     1.38128e+03     5.06586e-03</code></pre><pre><code class="language-julia">mf = reshape(prj(sol.sol), n) # optimal solution
ϕ = sol.f_trace   # cost vs iteration
m1 = sol.x_trace  # model vs iteration
collect(m1[i] = reshape(m1[i], n) for i=1:length(ϕ));</code></pre><pre><code class="language-none">relative evolution to small, exiting PARSDMM (iteration 15)</code></pre><pre><code class="language-julia">mf2 = reshape(prj(sol2.sol), n) # optimal solution
ϕ2 = sol2.f_trace   # cost vs iteration
m2 = sol2.x_trace  # model vs iteration
collect(m2[i] = reshape(m2[i], n) for i=1:length(ϕ2));</code></pre><pre><code class="language-none">relative evolution to small, exiting PARSDMM (iteration 15)</code></pre><h2 id=".-Visualize-velocity-models-and-objective-function"><a class="docs-heading-anchor" href="#.-Visualize-velocity-models-and-objective-function">11. Visualize velocity models and objective function</a><a id=".-Visualize-velocity-models-and-objective-function-1"></a><a class="docs-heading-anchor-permalink" href="#.-Visualize-velocity-models-and-objective-function" title="Permalink"></a></h2><pre><code class="language-julia">figure(figsize=(8,9)); clf()

subplot(4,1,1);imshow(m0&#39;,aspect=&quot;auto&quot;,cmap=&quot;jet&quot;);
colorbar(orientation=&quot;vertical&quot;);clim(vmin,vmax);title(&quot;Initial Velocity&quot;);

subplot(4,1,2);imshow(mf2&#39;,aspect=&quot;auto&quot;,cmap=&quot;jet&quot;);
colorbar(orientation=&quot;vertical&quot;);clim(vmin,vmax);title(&quot;FWI Velocity&quot;);

subplot(4,1,3);imshow(mf&#39;,aspect=&quot;auto&quot;,cmap=&quot;jet&quot;);
colorbar(orientation=&quot;vertical&quot;);clim(vmin,vmax);title(&quot;FWI Velocity with TV&quot;);

subplot(4,1,4);imshow(m&#39;,aspect=&quot;auto&quot;,cmap=&quot;jet&quot;);
colorbar(orientation=&quot;vertical&quot;);clim(vmin,vmax);title(&quot;True Velocity&quot;)

tight_layout()</code></pre><p><img src="../03_constr_fwi_judi_files/03_constr_fwi_judi_52_0.png" alt="png"/></p><h4 id="Display-the-velocity-difference-models"><a class="docs-heading-anchor" href="#Display-the-velocity-difference-models">Display the velocity difference models</a><a id="Display-the-velocity-difference-models-1"></a><a class="docs-heading-anchor-permalink" href="#Display-the-velocity-difference-models" title="Permalink"></a></h4><pre><code class="language-julia">rms_v2 = @sprintf(&quot;%.1f m/s&quot;, sqrt(norm(m .- m0)^2 / length(m)))
rms_vf = @sprintf(&quot;%.1f m/s&quot;, sqrt(norm(m .- mf)^2 / length(m)))
rms_vf2 = @sprintf(&quot;%.1f m/s&quot;, sqrt(norm(m .- mf2)^2 / length(m)))

figure(figsize=(8,6)); clf()

subplot(3,1,1);imshow(m .- m0,aspect=&quot;auto&quot;,cmap=&quot;seismic&quot;);
colorbar(orientation=&quot;vertical&quot;);clim(dmin,dmax);
title(&quot;Vtrue - Vinit difference, rms=$(rms_v2)&quot;);

subplot(3,1,2);imshow(m .- mf,aspect=&quot;auto&quot;,cmap=&quot;seismic&quot;);
colorbar(orientation=&quot;vertical&quot;);clim(dmin,dmax);
title(&quot;Vtrue - Vfwi difference, rms=$(rms_vf)&quot;);

subplot(3,1,3);imshow(m .- mf2,aspect=&quot;auto&quot;,cmap=&quot;seismic&quot;);
colorbar(orientation=&quot;vertical&quot;);clim(dmin,dmax);
title(&quot;Vtrue - Vfwi_TV difference, rms=$(rms_vf2)&quot;);

tight_layout()</code></pre><p><img src="../03_constr_fwi_judi_files/03_constr_fwi_judi_54_0.png" alt="png"/></p><h4 id="Display-the-cost-function"><a class="docs-heading-anchor" href="#Display-the-cost-function">Display the cost function</a><a id="Display-the-cost-function-1"></a><a class="docs-heading-anchor-permalink" href="#Display-the-cost-function" title="Permalink"></a></h4><pre><code class="language-julia">figure(figsize=(8,4)); clf()
iters = [0:1:niter;]
plot(ϕ[2:end] ./ ϕ[2], marker=&quot;o&quot;, label=&quot;FWI_TV&quot;)
plot(ϕ2[2:end] ./ ϕ2[2], marker=&quot;o&quot;, label=&quot;FWI&quot;)
ylim([0,1.05])
xlabel(&quot;Nonlinear Iteration&quot;)
ylabel(&quot;Normalized cost ||f(v) - d||&quot;)
title(@sprintf(&quot;FWI Objective Function reduced %.1f percent and %.1f percent with TV&quot;,
               100 * (ϕ[2] - ϕ[end]) / ϕ[2], 100 * (ϕ2[2] - ϕ2[end]) / ϕ2[2]));
tight_layout()</code></pre><p><img src="../03_constr_fwi_judi_files/03_constr_fwi_judi_56_0.png" alt="png"/></p><h4 id="Display-data-misfit-vs-model-misfit"><a class="docs-heading-anchor" href="#Display-data-misfit-vs-model-misfit">Display data misfit vs model misfit</a><a id="Display-data-misfit-vs-model-misfit-1"></a><a class="docs-heading-anchor-permalink" href="#Display-data-misfit-vs-model-misfit" title="Permalink"></a></h4><pre><code class="language-julia">figure(figsize=(8,4)); clf()

c = [norm(m1[i] .- m, 2) for i in 1:length(m1)]
c2 = [norm(m2[i] .- m, 2) for i in 1:length(m2)]
loglog(c[2:end], ϕ[2:end], label=&quot;FWI_TV&quot;, marker=&quot;s&quot;, linewidth=1)
loglog(c2[2:end], ϕ2[2:end], label=&quot;FWI&quot;, marker=&quot;s&quot;, linewidth=1)
legend()
xlabel(&quot;Log Model residual&quot;)
ylabel(&quot;Log Data residual&quot;)
title(&quot;Misfit Trajectory, LOOK AT THAT TV MODEL ERROR&quot;);
tight_layout()</code></pre><p><img src="../03_constr_fwi_judi_files/03_constr_fwi_judi_58_0.png" alt="png"/></p><h2 id=".-Visualize-data-match"><a class="docs-heading-anchor" href="#.-Visualize-data-match">12. Visualize data match</a><a id=".-Visualize-data-match-1"></a><a class="docs-heading-anchor-permalink" href="#.-Visualize-data-match" title="Permalink"></a></h2><h4 id="Generate-data-in-the-FWI-velocity-model"><a class="docs-heading-anchor" href="#Generate-data-in-the-FWI-velocity-model">Generate data in the FWI velocity model</a><a id="Generate-data-in-the-FWI-velocity-model-1"></a><a class="docs-heading-anchor-permalink" href="#Generate-data-in-the-FWI-velocity-model" title="Permalink"></a></h4><pre><code class="language-julia">tf = @elapsed begin
    F0.model.m .= vec(mf)
    df = F0*fsrc;
end
@show tf;

tf2 = @elapsed begin
    F0.model.m .= vec(mf2)
    df2 = F0*fsrc;
end
@show tf2;</code></pre><pre><code class="language-none">tf = 8.125829833
tf2 = 8.094312038</code></pre><h4 id="Compute-residuals"><a class="docs-heading-anchor" href="#Compute-residuals">Compute residuals</a><a id="Compute-residuals-1"></a><a class="docs-heading-anchor-permalink" href="#Compute-residuals" title="Permalink"></a></h4><pre><code class="language-julia">rf = df - dobs;
rf2 = df2 - dobs;</code></pre><h4 id="Plot-shot-gathers-for-true,-initial-model,-and-fwi-models"><a class="docs-heading-anchor" href="#Plot-shot-gathers-for-true,-initial-model,-and-fwi-models">Plot shot gathers for true, initial model, and fwi models</a><a id="Plot-shot-gathers-for-true,-initial-model,-and-fwi-models-1"></a><a class="docs-heading-anchor-permalink" href="#Plot-shot-gathers-for-true,-initial-model,-and-fwi-models" title="Permalink"></a></h4><p>The table below describes the data images below. We will flip the direction of the residual and modeled data in order to help display the match with the true data. We include the initial data as shown above for easier comparison. </p><table style="border:1px solid black;" width="60%">
<tr>
  <td style="border:1px solid black; text-align:center;" bgcolor="white">
      <b>Initial Residual Data<br>(flipped)</b></td>
  <td style="border:1px solid black; text-align:center;" bgcolor="white">
      <b>True Data</b></td>
  <td style="border:1px solid black; text-align:center;" bgcolor="white">
      <b>Initial Data<br>(flipped)</b></td>
</tr>
<tr>
  <td style="border:1px solid black; text-align:center;" bgcolor="white">
      <b>FWI Residual Data<br>(flipped)</b></td>
  <td style="border:1px solid black; text-align:center;" bgcolor="white">
      <b>True Data</b></td>
  <td style="border:1px solid black; text-align:center;" bgcolor="white">
      <b>FWI Data<br>(flipped)</b></td>
</tr>
</table><p>We first make a function to create the plots that we can re-use for the selected shots.</p><pre><code class="language-julia">zsrc = trunc.(zsrc; digits=6)
function make_plot(index)
    figure(figsize=(8,6)); clf()
    cat2 = hcat(reverse(r.data[index],dims=2), pad, dobs.data[index], pad, reverse(d0.data[index],dims=2))
    catf = hcat(reverse(rf.data[index],dims=2), pad, dobs.data[index], pad, reverse(df.data[index],dims=2))
    catf2 = hcat(reverse(rf2.data[index],dims=2), pad, dobs.data[index], pad, reverse(df.data[index],dims=2))
    subplot(3,1,1);
    imshow(cat2,cmap=&quot;gray&quot;,aspect=&quot;auto&quot;,clim=[-1,+1]);
    title(&quot; Initial Residual sz=$(zsrc[index])   ||   True sz=$(zsrc[index])   ||   Initial sz=$(zsrc[index]) (flipped)&quot;);
    subplot(3,1,2);
    imshow(catf2,cmap=&quot;gray&quot;,aspect=&quot;auto&quot;,clim=[-1,+1]);
    title(&quot; FWI Residual sz=$(zsrc[index])   ||   True sz=$(zsrc[index])   ||   FWI sz=$(zsrc[index]) (flipped)&quot;);
    tight_layout()
    subplot(3,1,3);
    imshow(catf,cmap=&quot;gray&quot;,aspect=&quot;auto&quot;,clim=[-1,+1]);
    title(&quot;TV FWI Residual sz=$(zsrc[index])   ||   True sz=$(zsrc[index])   ||   FWI sz=$(zsrc[index]) (flipped)&quot;);
    tight_layout()
end</code></pre><pre><code class="language-none">make_plot (generic function with 1 method)</code></pre><h4 id="Data-for-the-1st-shot,-generated-in-the-initial-and-FWI-models"><a class="docs-heading-anchor" href="#Data-for-the-1st-shot,-generated-in-the-initial-and-FWI-models">Data for the 1st shot, generated in the initial and FWI models</a><a id="Data-for-the-1st-shot,-generated-in-the-initial-and-FWI-models-1"></a><a class="docs-heading-anchor-permalink" href="#Data-for-the-1st-shot,-generated-in-the-initial-and-FWI-models" title="Permalink"></a></h4><pre><code class="language-julia">make_plot(1)</code></pre><p><img src="../03_constr_fwi_judi_files/03_constr_fwi_judi_66_0.png" alt="png"/></p><h4 id="Data-for-the-4th-shot,-generated-in-the-initial-and-FWI-models"><a class="docs-heading-anchor" href="#Data-for-the-4th-shot,-generated-in-the-initial-and-FWI-models">Data for the 4th shot, generated in the initial and FWI models</a><a id="Data-for-the-4th-shot,-generated-in-the-initial-and-FWI-models-1"></a><a class="docs-heading-anchor-permalink" href="#Data-for-the-4th-shot,-generated-in-the-initial-and-FWI-models" title="Permalink"></a></h4><pre><code class="language-julia">make_plot(4)</code></pre><p><img src="../03_constr_fwi_judi_files/03_constr_fwi_judi_68_0.png" alt="png"/></p><h4 id="Data-for-the-8th-shot,-generated-in-the-initial-and-FWI-models"><a class="docs-heading-anchor" href="#Data-for-the-8th-shot,-generated-in-the-initial-and-FWI-models">Data for the 8th shot, generated in the initial and FWI models</a><a id="Data-for-the-8th-shot,-generated-in-the-initial-and-FWI-models-1"></a><a class="docs-heading-anchor-permalink" href="#Data-for-the-8th-shot,-generated-in-the-initial-and-FWI-models" title="Permalink"></a></h4><pre><code class="language-julia">make_plot(8)</code></pre><p><img src="../03_constr_fwi_judi_files/03_constr_fwi_judi_70_0.png" alt="png"/></p><h2 id=".-Remove-workers"><a class="docs-heading-anchor" href="#.-Remove-workers">14. Remove workers</a><a id=".-Remove-workers-1"></a><a class="docs-heading-anchor-permalink" href="#.-Remove-workers" title="Permalink"></a></h2><pre><code class="language-julia">rmprocs(workers());</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../02_simple_constrained/">« Constrained Inversion, basics</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 22 December 2020 14:05">Tuesday 22 December 2020</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
